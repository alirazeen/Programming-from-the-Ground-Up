# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2006-05-15 16:01+0800\n"
"PO-Revision-Date: 2006-07-30 17:52+0800\n"
"Last-Translator: Zhang Le <robert.zhangle@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING\n"
"X-Generator: Pootle 0.10beta3\n"

# type: Content of: <chapter><title>
#: ../../LinkingCh.xml:2
#, no-wrap
msgid "Sharing Functions with Code Libraries"
msgstr "使用库来共享函数"

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:17
msgid ""
"By now you should realize that the computer has to do a lot of work even for "
"simple tasks.  Because of that, you have to do a lot of work to write the "
"code for a computer to even do simple tasks.  In addition, programming tasks "
"are usually not very simple.  Therefore, we neeed a way to make this process "
"easier on ourselves.  There are several ways to do this, including:"
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:25
msgid "Write code in a high-level language instead of assembly language"
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:26
msgid ""
"Have lots of pre-written code that you can cut and paste into your own "
"programs"
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:27
msgid "Have a set of functions<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:27 ../../LinkingCh.xml:261
#, no-wrap
msgid "functions"
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:27
msgid ""
"</indexterm> on the system that are shared among any program that wishes to "
"use it"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:30
msgid ""
"All three of these are usually used to some degree in any given project.  "
"The first option will be explored further in <xref "
"linkend=\"highlevellanguages\" />.  The second option is useful but it "
"suffers from some drawbacks, including:"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:37
msgid ""
"Code that is copied often has to be majorly modified to fit the surrounding "
"code."
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:38
msgid ""
"Every program containing the copied code has the same code in it, thus "
"wasting a lot of space."
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:39
msgid ""
"If a bug is found in any of the copied code it has to be fixed in every "
"application program."
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:43
msgid ""
"Therefore, the second option is usually used sparingly.  It is usually only "
"used in cases where you copy and paste skeleton code<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../LinkingCh.xml:44
#, no-wrap
msgid "skeleton code"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:44
msgid ""
"</indexterm> for a specific type of task, and add in your program-specific "
"details.  The third option is the one that is used the most often.  The "
"third option includes having a central repository of shared code.  Then, "
"instead of each program wasting space storing the same copies of functions, "
"they can simply point to the <emphasis>dynamic libraries</emphasis> "
"<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../LinkingCh.xml:48 ../../LinkingCh.xml:68
#, no-wrap
msgid "shared libraries"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:48
msgid "</indexterm> <indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:48 ../../LinkingCh.xml:68 ../../LinkingCh.xml:103 ../../LinkingCh.xml:156
#, no-wrap
msgid "dynamic libraries"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:48
msgid ""
"</indexterm> which contain the functions they need.  If a bug is found in "
"one of these functions, it only has to be fixed within the single function "
"library file, and all applications which use it are automatically updated.  "
"The main drawback with this approach is that it creates some dependency "
"problems, including:"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:57
msgid ""
"If multiple applications are all using the same file, how do we know when it "
"is safe to delete the file? For example, if three applications are sharing a "
"file of functions and 2 of the programs are deleted, how does the system "
"know that there still exists an application that uses that code, and "
"therefore it shouldn't be deleted?"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:58
msgid ""
"Some programs inadvertantly rely on bugs within shared functions.  "
"Therefore, if upgrading the shared functions fixes a bug that a program "
"depended on, it could cause that application to cease functioning."
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:62
msgid ""
"These problems are what lead to what is known as \"DLL hell\".  However, it "
"is generally assumed that the advantages outweigh the disadvantages."
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:67
msgid ""
"In programming, these shared code files are referred to as <emphasis>shared "
"libraries</emphasis> <indexterm>"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:68
msgid "</indexterm>, <emphasis>dynamic libraries</emphasis> <indexterm>"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:68
msgid "</indexterm>, <emphasis>shared objects<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../LinkingCh.xml:69
#, no-wrap
msgid "shared objects"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:69
msgid "</indexterm></emphasis>, <emphasis>dynamic-link libraries<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../LinkingCh.xml:70
#, no-wrap
msgid "dynamic-link libraries"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:70
msgid "</indexterm></emphasis>, <emphasis>DLLs<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../LinkingCh.xml:71
#, no-wrap
msgid "DLLs"
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:71
msgid "</indexterm></emphasis>, or <emphasis>.so files</emphasis>.<footnote>"
msgstr ""

# type: Content of: <chapter><para><para>
#: ../../LinkingCh.xml:71
msgid ""
"Each of these terms have slightly different meanings, but most people use "
"them interchangeably anyway.  Specifically, this chapter will cover dynamic "
"libraries, but not shared libraries.  Shared libraries are dynamic libraries "
"which are built using <emphasis>position-independent "
"code</emphasis><indexterm>"
msgstr ""

# type: Content of: <chapter><para><para><primary>
#: ../../LinkingCh.xml:71
#, no-wrap
msgid "position-independent code"
msgstr ""

# type: Content of: <chapter><para><para>
#: ../../LinkingCh.xml:71
msgid "</indexterm> (often abbreviated PIC<indexterm>"
msgstr ""

# type: Content of: <chapter><para><para><primary>
#: ../../LinkingCh.xml:71
#, no-wrap
msgid "PIC"
msgstr ""

# type: Content of: <chapter><para><para>
#: ../../LinkingCh.xml:71
msgid ""
"</indexterm>) which is outside the scope of this book.  However, shared "
"libraries and dynamic libraries are used in the same way by users and "
"programs; the linker just links them differently."
msgstr ""

# type: Content of: <chapter><para>
#: ../../LinkingCh.xml:71
msgid ""
"</footnote> We will refer to all of these as <emphasis>dynamic "
"libraries</emphasis>."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../LinkingCh.xml:75
#, no-wrap
msgid "Using a Dynamic Library"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:78
msgid ""
"The program we will examine here is simple - it writes the characters "
"<literal>hello world</literal> to the screen and exits.  The regular "
"program, <filename>helloworld-nolib.s</filename>, looks like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:90
msgid ""
"That's not too long.  However, take a look at how short "
"<filename>helloworld-lib</filename> is which uses a library:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:99
msgid "It's even shorter!"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:103
msgid "Now, building programs which use dynamic libraries<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:103
msgid ""
"</indexterm> is a little different than normal.  You can build the first "
"program normally by doing this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:114
msgid "However, in order to build the second program, you have to do this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:124
msgid ""
"Remember, the backslash in the first line simply means that the command "
"continues on the next line.  The option <literal>-dynamic-linker<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:125
#, no-wrap
msgid "-dynamic-linker"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:125
msgid ""
"</indexterm> /lib/ld-linux.so.2</literal> allows our program to be linked to "
"libraries.  This builds the executable so that before executing, the "
"operating system will load the program "
"<filename>/lib/ld-linux.so.2</filename> to load in external libraries and "
"link them with the program.  This program is known as a <emphasis>dynamic "
"linker<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:131 ../../LinkingCh.xml:155 ../../LinkingCh.xml:195
#, no-wrap
msgid "dynamic linker"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:131
msgid "</indexterm></emphasis>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:135
msgid ""
"The <literal>-lc</literal> option says to link to the <literal>c</literal> "
"library, named <filename>libc.so</filename> on GNU/Linux systems.  Given a "
"library name, <literal>c</literal> in this case (usually library names are "
"longer than a single letter), the GNU/Linux linker prepends the string "
"<literal>lib</literal> to the beginning of the library name and appends "
"<literal>.so</literal> to the end of it to form the library's filename.  "
"This library contains many functions to automate all types of tasks.  The "
"two we are using are <literal>printf<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:144 ../../LinkingCh.xml:289 ../../LinkingCh.xml:347
#, no-wrap
msgid "printf"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:144
msgid "</indexterm></literal>, which prints strings, and <literal>exit<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:145
#, no-wrap
msgid "exit"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:145
msgid "</indexterm></literal>, which exits the program."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:149
msgid ""
"Notice that the symbols <literal>printf</literal> and "
"<literal>exit</literal> are simply referred to by name within the program.  "
"In previous chapters, the linker would resolve all of the names to physical "
"memory addresses, and the names would be thrown away.  When using dynamic "
"linking<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:152
#, no-wrap
msgid "dynamic linking"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:152
msgid ""
"</indexterm>, the name itself resides within the executable, and is resolved "
"by the dynamic linker when it is run.  When the program is run by the user, "
"the dynamic linker<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:155
msgid "</indexterm> loads the dynamic libraries<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:156
msgid ""
"</indexterm> listed in our link statement, and then finds all of the "
"function and variable names that were named by our program but not found at "
"link time, and matches them up with corresponding entries in the shared "
"libraries it loads.  It then replaces all of the names with the addresses "
"which they are loaded at.  This sounds time-consuming.  It is to a small "
"degree, but it only happens once - at program startup time."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../LinkingCh.xml:167
#, no-wrap
msgid "How Dynamic Libraries Work"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:170
msgid ""
"In our first programs, all of the code was contained within the source "
"file.  Such programs are called <emphasis>statically-linked "
"executables<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:172
#, no-wrap
msgid "statically-linked"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:172
msgid ""
"</indexterm></emphasis>, because they contained all of the necessary "
"functionality for the program that wasn't handled by the kernel.  In the "
"programs we wrote in <xref linkend=\"records\" />, we used both our main "
"program file and files containing routines used by multiple programs.  In "
"these cases, we combined all of the code together using the linker at "
"link-time, so it was still statically-linked.  However, in the "
"<literal>helloworld-lib</literal> program, we started using dynamic "
"libraries.  When you use dynamic libraries, your program is then "
"<emphasis>dynamically-linked<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:181
#, no-wrap
msgid "dynamically-linked"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:181
msgid ""
"</indexterm></emphasis>, which means that not all of the code needed to run "
"the program is actually contained within the program file itself, but in "
"external libraries."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:187
msgid ""
"When we put the <literal>-lc</literal> on the command to link the "
"<literal>helloworld</literal> program, it told the linker to use the "
"<literal>c</literal> library (<filename>libc.so</filename>) to look up any "
"symbols<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:189
#, no-wrap
msgid "symbols"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:189
msgid ""
"</indexterm> that weren't already defined in "
"<filename>helloworld.o</filename>.  However, it doesn't actually add any "
"code to our program, it just notes in the program where to look.  When the "
"<literal>helloworld</literal> program begins, the file "
"<filename>/lib/ld-linux.so.2<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:194
#, no-wrap
msgid "/lib/ld-linux.so.2"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:194
msgid ""
"</indexterm></filename> is loaded first.  This is the dynamic "
"linker<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:195
msgid ""
"</indexterm>.  This looks at our <literal>helloworld</literal> program and "
"sees that it needs the <literal>c</literal> library to run.  So, it searches "
"for a file called <filename>libc.so</filename> in the standard places "
"(listed in <filename>/etc/ld.so.conf<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:198 ../../LinkingCh.xml:611
#, no-wrap
msgid "/etc/ld.so.conf"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:198
msgid ""
"</indexterm></filename> and in the contents of the "
"<literal>LD_LIBRARY_PATH<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><primary>
#: ../../LinkingCh.xml:199 ../../LinkingCh.xml:620
#, no-wrap
msgid "LD_LIBRARY_PATH"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:199
msgid ""
"</indexterm></literal> environment variable), then looks in it for all the "
"needed symbols (<literal>printf</literal> and <literal>exit</literal> in "
"this case), and then loads the library into the program's virtual memory.  "
"Finally, it replaces all instances of <literal>printf</literal> in the "
"program with the actual location of <literal>printf</literal> in the "
"library."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:209
msgid "Run the following command:"
msgstr ""

# type: Content of: <chapter><sect1><para><programlisting><primary>
#: ../../LinkingCh.xml:212
#, no-wrap
msgid "ldd"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:215
msgid ""
"It should report back <literal>not a dynamic executable</literal>.  This is "
"just like we said - <literal>helloworld-nolib</literal> is a "
"statically-linked executable.  However, try this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:223
msgid "It will report back something like"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:230
msgid ""
"The numbers in parenthesis may be different on your system.  This means that "
"the program <literal>helloworld</literal> is linked to "
"<filename>libc.so.6</filename> (the <literal>.6</literal> is the version "
"number), which is found at <filename>/lib/libc.so.6</filename>, and "
"<filename>/lib/ld-linux.so.2</filename> is found at "
"<filename>/lib/ld-linux.so.2</filename>.  These libraries have to be loaded "
"before the program can be run.  If you are interested, run the "
"<literal>ldd</literal> program on various programs that are on your Linux "
"distribution, and see what libraries they rely on."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../LinkingCh.xml:244
#, no-wrap
msgid "Finding Information about Libraries"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:247
msgid ""
"Okay, so now that you know about libraries, the question is, how do you find "
"out what libraries you have on your system and what they do? Well, let's "
"skip that question for a minute and ask another question: How do programmers "
"describe functions to each other in their documentation? Let's take a look "
"at the function <literal>printf</literal>.  Its calling interface<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:252
#, no-wrap
msgid "calling interface"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:252
msgid "</indexterm> (usually referred to as a <emphasis>prototype<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:253
#, no-wrap
msgid "prototype"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:253
msgid "</indexterm></emphasis>) looks like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:261
msgid "In Linux, functions<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:261
msgid "</indexterm> are described in the C programming language<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:261 ../../LinkingCh.xml:364
#, no-wrap
msgid "C programming language"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:261
msgid ""
"</indexterm>.  In fact, most Linux programs are written in C.  That is why "
"most documentation and binary compatibility is defined using the C "
"language.  The interface to the <literal>printf</literal> function above is "
"described using the C programming language."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:268
msgid ""
"This definition means that there is a function <literal>printf</literal>.  "
"The things inside the parenthesis are the function's parameters<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:269
#, no-wrap
msgid "parameters"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:269
msgid ""
"</indexterm> or arguments.  The first parameter here is <literal>char "
"*string</literal>.  This means there is a parameter named "
"<literal>string</literal> (the name isn't important, except to use for "
"talking about it), which has a type <literal>char *</literal>.  "
"<literal>char<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:273 ../../LinkingCh.xml:401
#, no-wrap
msgid "char"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:273
msgid ""
"</indexterm></literal> means that it wants a single-byte character.  The "
"<literal>*<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:274 ../../LinkingCh.xml:434
#, no-wrap
msgid "*"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:274
msgid ""
"</indexterm></literal> after it means that it doesn't actually want a "
"character as an argument, but instead it wants the address of a character or "
"sequence of characters.  If you look back at our <literal>helloworld "
"program</literal>, you will notice that the function call looked like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:287
msgid ""
"So, we pushed the address of the <literal>hello</literal> string, rather "
"than the actual characters.  You might notice that we didn't push the length "
"of the string.  The way that <literal>printf<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:289
msgid ""
"</indexterm></literal> found the end of the string was because we ended it "
"with a null character<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:290
#, no-wrap
msgid "null character"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:290
msgid ""
"</indexterm> (<literal>\\0</literal>).  Many functions work that way, "
"especially C language functions.  The <literal>int<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:292 ../../LinkingCh.xml:373
#, no-wrap
msgid "int"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:292
msgid ""
"</indexterm></literal> before the function definition tell what type of "
"value the function will return in &eax-indexed; when it returns.  "
"<literal>printf</literal> will return an <literal>int</literal> when it's "
"through.  Now, after the <literal>char *string</literal>, we have a series "
"of periods, <literal>...<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:296
#, no-wrap
msgid "..."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:296
msgid ""
"</indexterm></literal>.  This means that it can take an indefinite number of "
"additional arguments after the string.  Most functions can only take a "
"specified number of arguments.  <literal>printf</literal>, however, can take "
"many.  It will look into the <literal>string</literal> parameter, and "
"everywhere it sees the characters <literal>%s</literal>, it will look for "
"another string from the stack to insert, and everywhere it sees "
"<literal>%d</literal> it will look for a number from the stack to insert.  "
"This is best described using an example:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:312
msgid ""
"Type it in with the filename <filename>printf-example.s</filename>, and then "
"do the following commands:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:323
msgid ""
"Then run the program with <literal>./printf-example</literal>, and it should "
"say this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:332
msgid ""
"Now, if you look at the code, you'll see that we actually push the format "
"string last, even though it's the first parameter listed.  You always push a "
"functions parameters in reverse order.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../LinkingCh.xml:336
msgid ""
"The reason that parameters are pushed in the reverse order is because of "
"functions which take a variable number of parameters like "
"<literal>printf</literal>.  The parameters pushed in last will be in a known "
"position relative to the top of the stack.  The program can then use these "
"parameters to determine where on the stack the additional arguments are, and "
"what type they are.  For example, <literal>printf</literal> uses the format "
"string to determine how many other parameters are being sent.  If we pushed "
"the known arguments first, you wouldn't be able to tell where they were on "
"the stack."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:345
msgid "</footnote> You may be wondering how the <literal>printf<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:347
msgid ""
"</indexterm></literal> function knows how many parameters there are.  Well, "
"it searches through your string, and counts how many <literal>%d</literal>s "
"and <literal>%s</literal>s it finds, and then grabs that number of "
"parameters from the stack.  If the parameter matches a "
"<literal>%d</literal>, it treats it as a number, and if it matches a "
"<literal>%s</literal>, it treats it as a pointer to a null-terminated "
"string.  <literal>printf</literal> has many more features than this, but "
"these are the most-used ones.  So, as you can see, <literal>printf</literal> "
"can make output a lot easier, but it also has a lot of overhead, because it "
"has to count the number of characters in the string, look through it for all "
"of the control characters it needs to replace, pull them off the stack, "
"convert them to a suitable representation (numbers have to be converted to "
"strings, etc), and stick them all together appropriately."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:364
msgid "We've seen how to use the C programming language<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:364
msgid "</indexterm> prototypes<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:364
#, no-wrap
msgid "prototypes"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:364
msgid ""
"</indexterm> to call library functions.  To use them effectively, however, "
"you need to know several more of the possible data types for reading "
"functions.  Here are the main ones:"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:373
#, no-wrap
msgid "<literal>int<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:373 ../../LinkingCh.xml:380 ../../LinkingCh.xml:387 ../../LinkingCh.xml:394 ../../LinkingCh.xml:401 ../../LinkingCh.xml:409 ../../LinkingCh.xml:417 ../../LinkingCh.xml:425 ../../LinkingCh.xml:434 ../../LinkingCh.xml:452 ../../LinkingCh.xml:475
#, no-wrap
msgid "</indexterm></literal>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:375
msgid "An <literal>int</literal> is an integer number (4 bytes on x86 processor)."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:380
#, no-wrap
msgid "<literal>long<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:380
#, no-wrap
msgid "long"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:382
msgid ""
"A <literal>long</literal> is also an integer number (4 bytes on an x86 "
"processor)."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:387
#, no-wrap
msgid "<literal>long long<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:387
#, no-wrap
msgid "long long"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:389
msgid ""
"A <literal>long long</literal> is an integer number that's larger than a "
"<literal>long</literal> (8 bytes on an x86 processor)."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:394
#, no-wrap
msgid "<literal>short<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:394
#, no-wrap
msgid "short"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:396
msgid ""
"A short is an integer number that's shorter than an <literal>int</literal> "
"(2 bytes on an x86 processor)."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:401
#, no-wrap
msgid "<literal>char<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:403
msgid ""
"A <literal>char</literal> is a single-byte integer number.  This is mostly "
"used for storing character data, since ASCII strings usually are represented "
"with one byte per character."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:409
#, no-wrap
msgid "<literal>float<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:409
#, no-wrap
msgid "float"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:411
msgid ""
"A <literal>float</literal> is a floating-point number (4 bytes on an x86 "
"processor).  Floating-point numbers will be explained in more depth in <xref "
"linkend=\"floatingpoint\" />."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:417
#, no-wrap
msgid "<literal>double<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:417
#, no-wrap
msgid "double"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:419
msgid ""
"A <literal>double</literal> is a floating-point number that is larger than a "
"float (8 bytes on an x86 processor)."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:425
#, no-wrap
msgid "<literal>unsigned<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:425
#, no-wrap
msgid "unsigned"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:427
msgid ""
"<literal>unsigned</literal> is a modifier used for any of the above types "
"which keeps them from being used as signed quantities.  The difference "
"between signed and unsigned numbers will be discussed in <xref "
"linkend=\"countingchapter\" />."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:434
#, no-wrap
msgid "<literal>*<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:436
msgid ""
"An asterisk (<literal>*</literal>) is used to denote that the data isn't an "
"actual value, but instead is a pointer to a location holding the given value "
"(4 bytes on an x86 processor).  So, let's say in memory location "
"<literal>my_location</literal> you have the number 20 stored.  If the "
"prototype said to pass an <literal>int</literal>, you would use direct "
"addressing mode<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para><primary>
#: ../../LinkingCh.xml:441
#, no-wrap
msgid "direct addressing mode"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:441
msgid ""
"</indexterm> and do <literal>pushl my_location</literal>.  However, if the "
"prototype said to pass an <literal>int *</literal>, you would do "
"<literal>pushl $my_location</literal> - an immediate mode<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para><primary>
#: ../../LinkingCh.xml:443
#, no-wrap
msgid "immediate mode addressing"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:443
msgid ""
"</indexterm> push of the address that the value resides in.  In addition to "
"indicating the address of a single value, pointers can also be used to pass "
"a sequence of consecutive locations, starting with the one pointed to by the "
"given value.  This is called an array<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para><primary>
#: ../../LinkingCh.xml:447
#, no-wrap
msgid "array"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:447
msgid "</indexterm>."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:452
#, no-wrap
msgid "<literal>struct<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:452
#, no-wrap
msgid "struct"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:454
msgid ""
"A <literal>struct</literal> is a set of data items that have been put "
"together under a name.  For example you could declare:"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:464
msgid ""
"and any time you ran into <literal>struct teststruct</literal> you would "
"know that it is actually two words right next to each other, the first being "
"an integer, and the second a pointer to a character or group of characters.  "
"You never see structs passed as arguments to functions.  Instead, you "
"usually see pointers to structs passed as arguments.  This is because "
"passing structs to functions is fairly complicated, since they can take up "
"so many storage locations."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../LinkingCh.xml:475
#, no-wrap
msgid "<literal>typedef<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../LinkingCh.xml:475
#, no-wrap
msgid "typedef"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../LinkingCh.xml:477
msgid ""
"A <literal>typedef</literal> basically allows you to rename a type.  For "
"example, I can do <literal>typedef int myowntype;</literal> in a C program, "
"and any time I typed <literal>myowntype</literal>, it would be just as if I "
"typed <literal>int</literal>.  This can get kind of annoying, because you "
"have to look up what all of the typedefs and structs in a function prototype "
"really mean.  However, <literal>typedef</literal>s are useful for giving "
"types more meaningful and descriptive names."
msgstr ""

# type: Content of: <chapter><sect1><note><title>
#: ../../LinkingCh.xml:490
#, no-wrap
msgid "Compatibility Note"
msgstr ""

# type: Content of: <chapter><sect1><note><para>
#: ../../LinkingCh.xml:492
msgid ""
"The listed sizes are for intel-compatible (x86) machines.  Other machines "
"will have different sizes.  Also, even when parameters shorter than a word "
"are passed to functions, they are passed as longs on the stack."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:499
msgid ""
"That's how to read function documentation.  Now, let's get back to the "
"question of how to find out about libraries.  Most of your system libraries "
"are in <filename>/usr/lib<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:501 ../../LinkingCh.xml:590
#, no-wrap
msgid "/usr/lib"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:501
msgid "</indexterm></filename> or <filename>/lib<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:502 ../../LinkingCh.xml:589
#, no-wrap
msgid "/lib"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:502
msgid ""
"</indexterm></filename>.  If you want to just see what symbols they define, "
"just run <literal>objdump<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:503
#, no-wrap
msgid "objdump"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:503
msgid ""
"</indexterm> -R FILENAME</literal> where <literal>FILENAME</literal> is the "
"full path to the library.  The output of that isn't too helpful, though, for "
"finding an interface that you might need.  Usually, you have to know what "
"library you want at the beginning, and then just read the documentation.  "
"Most libraries have manuals or man pages for their functions.  The web is "
"the best source of documentation for libraries.  Most libraries from the GNU "
"project also have info pages on them, which are a little more thorough than "
"man pages."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../LinkingCh.xml:517
#, no-wrap
msgid "Useful Functions"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:520
msgid ""
"Several useful functions you will want to be aware of from the "
"<literal>c</literal> library include:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:525
msgid "<literal>size_t strlen<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:525
#, no-wrap
msgid "strlen"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:525
msgid ""
"</indexterm> (const char *s)</literal> calculates the size of "
"null-terminated strings."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:526
msgid "<literal>int strcmp<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:526
#, no-wrap
msgid "strcmp"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:526
msgid ""
"</indexterm> (const char *s1, const char *s2)</literal> compares two strings "
"alphabetically."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:527
msgid "<literal>char * strdup<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:527
#, no-wrap
msgid "strdup"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:527
msgid ""
"</indexterm> (const char *s)</literal> takes the pointer to a string, and "
"creates a new copy in a new location, and returns the new location."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:528
msgid "<literal>FILE * fopen<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:528
#, no-wrap
msgid "fopen"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:528
msgid ""
"</indexterm> (const char *filename, const char *opentype)</literal> opens a "
"managed, buffered file (allows easier reading and writing than using file "
"descriptors directly).<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><para>
#: ../../LinkingCh.xml:528
msgid ""
"<literal>stdin</literal>, <literal>stdout</literal>, and "
"<literal>stderr</literal> (all lower case) can be used in these programs to "
"refer to the files of their corresponding file descriptors."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:528
msgid "</footnote><footnote>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><para>
#: ../../LinkingCh.xml:528
msgid ""
"<literal>FILE</literal> is a struct.  You don't need to know its contents to "
"use it.  You only have to store the pointer and pass it to the relevant "
"other functions."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:528
msgid "</footnote>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:529
msgid "<literal>int fclose<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:529
#, no-wrap
msgid "fclose"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:529
msgid ""
"</indexterm> (FILE *stream)</literal> closes a file opened with "
"<literal>fopen</literal>."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:530
msgid "<literal>char * fgets<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:530
#, no-wrap
msgid "fgets"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:530
msgid ""
"</indexterm> (char *s, int count, FILE *stream)</literal> fetches a line of "
"characters into string <literal>s</literal>."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:531
msgid "<literal>int fputs<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:531
#, no-wrap
msgid "fputs"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:531
msgid ""
"</indexterm> (const char *s, FILE *stream)</literal> writes a string to the "
"given open file."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:532
msgid "<literal>int fprintf<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:532
#, no-wrap
msgid "fprintf"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:532
msgid ""
"</indexterm> (FILE *stream, const char *template, ...)</literal> is just "
"like <literal>printf</literal>, but it uses an open file rather than "
"defaulting to using standard output."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:536
msgid ""
"You can find the complete manual on this library by going to "
"http://www.gnu.org/software/libc/manual/"
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../LinkingCh.xml:542
#, no-wrap
msgid "Building a Dynamic Library"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:545
msgid ""
"Let's say that we wanted to take all of our shared code from <xref "
"linkend=\"records\" /> and build it into a dynamic library<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../LinkingCh.xml:546 ../../LinkingCh.xml:567
#, no-wrap
msgid "dynamic library"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:546
msgid ""
"</indexterm> to use in our programs.  The first thing we would do is "
"assemble them like normal:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:557
msgid ""
"Now, instead of linking them into a program, we want to link them into a "
"dynamic library.  This changes our linker command to this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:567
msgid "This links both of these files together into a dynamic library<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:567
msgid ""
"</indexterm> called <filename>librecord.so</filename>.  This file can now be "
"used for multiple programs.  If we need to update the functions contained "
"within it, we can just update this one file and not have to worry about "
"which programs use it."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:575
msgid ""
"Let's look at how we would link against this library.  To link the "
"<literal>write-records</literal> program, we would do the following:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:587
msgid ""
"In this command, <literal>-L .</literal> told the linker to look for "
"libraries in the current directory (it usually only searches "
"<filename>/lib<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:589
msgid "</indexterm></filename> directory, <filename>/usr/lib<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:590
msgid ""
"</indexterm></filename> directory, and a few others).  As we've seen, the "
"option <literal>-dynamic-linker /lib/ld-linux.so.2</literal> specified the "
"dynamic linker.  The option <literal>-lrecord</literal> tells the linker to "
"search for functions in the file named <filename>librecord.so</filename>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:598
msgid ""
"Now the <literal>write-records</literal> program is built, but it will not "
"run.  If we try it, we will get an error like the following:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:609
msgid ""
"This is because, by default, the dynamic linker only searches "
"<filename>/lib</filename>, <filename>/usr/lib</filename>, and whatever "
"directories are listed in <filename>/etc/ld.so.conf<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:611
msgid ""
"</indexterm></filename> for libraries.  In order to run the program, you "
"either need to move the library to one of these directories, or execute the "
"following command:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:623
msgid "Alternatively, if that gives you an error, do this instead:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:631
msgid ""
"Now, you can run <literal>write-records</literal> normally by typing "
"<literal>./write-records</literal>.  Setting "
"<literal>LD_LIBRARY_PATH</literal> tells the linker to add whatever paths "
"you give it to the library search path for dynamic libraries."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../LinkingCh.xml:638
msgid ""
"For further information about dynamic linking, see the following sources on "
"the Internet:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:643
msgid ""
"The man page for <literal>ld.so</literal> contains a lot of information "
"about how the Linux dynamic linker works."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:644
msgid ""
"http://www.benyossef.com/presentations/dlink/ is a great presentation on "
"dynamic linking in Linux."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:645
msgid ""
"http://www.linuxjournal.com/article.php?sid=1059 and "
"http://www.linuxjournal.com/article.php?sid=1060 provide a good introduction "
"to the ELF<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../LinkingCh.xml:645
#, no-wrap
msgid "ELF"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:645
msgid ""
"</indexterm> file format, with more detail available at "
"http://www.cs.ucdavis.edu/~haungs/paper/node10.html"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:646
msgid ""
"http://www.iecc.com/linker/linker10.html contains a great description of how "
"dynamic linking works with ELF files."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:647
msgid "http://linux4u.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node21.html contains a good introduction to programming position-independent code for shared libraries under Linux."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../LinkingCh.xml:654
#, no-wrap
msgid "Review"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../LinkingCh.xml:657
#, no-wrap
msgid "Know the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:660
msgid "What are the advantages and disadvantages of shared libraries?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:661
msgid "Given a library named 'foo', what would the library's filename be?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:662
msgid "What does the <literal>ldd</literal> command do?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:663
msgid ""
"Let's say we had the files <filename>foo.o</filename> and "
"<filename>bar.o</filename>, and you wanted to link them together, and "
"dynamically link them to the library 'kramer'.  What would the linking "
"command be to generate the final executable?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:664
msgid "What is <emphasis>typedef</emphasis> for?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:665
msgid "What are <emphasis>struct</emphasis>s for?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:666
msgid ""
"What is the difference between a data element of type "
"<emphasis>int</emphasis> and <emphasis>int *</emphasis>? How would you "
"access them differently in your program?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:667
msgid ""
"If you had a object file called <filename>foo.o</filename>, what would be "
"the command to create a shared library called 'bar'?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:668
msgid "What is the purpose of LD_LIBRARY_PATH?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../LinkingCh.xml:674
#, no-wrap
msgid "Use the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:677
msgid ""
"Rewrite one or more of the programs from the previous chapters to print "
"their results to the screen using <literal>printf</literal> rather than "
"returning the result as the exit status code.  Also, make the exit status "
"code be 0."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:678
msgid ""
"Use the <literal>factorial</literal> function you developed in <xref "
"linkend=\"recursivefunctions\" /> to make a shared library.  Then re-write "
"the main program so that it links with the library dynamically."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:679
msgid ""
"Rewrite the program above so that it also links with the 'c' library.  Use "
"the 'c' library's <literal>printf</literal> function to display the result "
"of the <literal>factorial</literal> call."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:680
msgid ""
"Rewrite the <literal>toupper</literal> program so that it uses the "
"<literal>c</literal> library functions for files rather than system calls."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../LinkingCh.xml:686
#, no-wrap
msgid "Going Further"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:689
msgid ""
"Make a list of all the environment variables used by the GNU/Linux dynamic "
"linker."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:690
msgid ""
"Research the different types of executable file formats in use today and in "
"the history of computing.  Tell the strengths and weaknesses of each."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:691
msgid ""
"What kinds of programming are you interested in (graphics, databbases, "
"science, etc.)? Find a library for working in that area, and write a program "
"that makes some basic use of that library."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../LinkingCh.xml:692
msgid ""
"Research the use of <literal>LD_PRELOAD</literal>.  What is it used for? Try "
"building a shared library that contained the <literal>exit</literal> "
"function, and have it write a message to STDERR before exitting.  Use "
"<literal>LD_PRELOAD</literal> and run various programs with it.  What are "
"the results?"
msgstr ""
